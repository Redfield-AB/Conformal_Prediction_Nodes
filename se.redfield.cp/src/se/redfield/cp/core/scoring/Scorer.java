/*
 * Copyright (c) 2020 Redfield AB.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License, Version 3, as
 * published by the Free Software Foundation.
 *  
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, see <http://www.gnu.org/licenses>.
 */
package se.redfield.cp.core.scoring;

import static java.util.stream.Collectors.toSet;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.stream.Collectors;

import org.knime.core.data.DataCell;
import org.knime.core.data.DataColumnSpec;
import org.knime.core.data.DataColumnSpecCreator;
import org.knime.core.data.DataRow;
import org.knime.core.data.DataTableSpec;
import org.knime.core.data.DoubleValue;
import org.knime.core.data.RowKey;
import org.knime.core.data.collection.CollectionDataValue;
import org.knime.core.data.def.DefaultRow;
import org.knime.core.data.def.StringCell;
import org.knime.core.node.BufferedDataContainer;
import org.knime.core.node.BufferedDataTable;
import org.knime.core.node.CanceledExecutionException;
import org.knime.core.node.ExecutionContext;

import se.redfield.cp.core.scoring.ScoreColumn.LongScoreColumn;
import se.redfield.cp.core.scoring.Scores.ClassScores;
import se.redfield.cp.core.scoring.Scores.Metric;
import se.redfield.cp.nodes.ConformalPredictorScorerNodeModel;

/**
 * Class used to evaluate data generated by Conformal Classifier Node. Collects
 * different metrics for each class.
 * 
 * @author Alexander Bondaletov
 *
 */
public class Scorer {
	private ConformalPredictorScorerNodeModel model;
	private List<ScoreColumn> baseColumns;
	private List<ScoreColumn> additionalColumns;
	private List<ScoreColumn> additionalEfficiencyColumns;

	/**
	 * @param conformalPredictorScorerNodeModel The node model
	 */
	public Scorer(ConformalPredictorScorerNodeModel conformalPredictorScorerNodeModel) {
		this.model = conformalPredictorScorerNodeModel;
		baseColumns = Arrays.asList(//
				new ScoreColumn("Efficiency", Metric.SINGLE_CLASS, true), //
				new ScoreColumn("Validity", s -> s.getAvg(Metric.SOFT_MATCH) + s.getAvg(Metric.STRICT_MATCH)));

		additionalColumns = Arrays.asList(//
				new LongScoreColumn("Exact match", Metric.STRICT_MATCH), //
				new LongScoreColumn("Soft match", Metric.SOFT_MATCH), //
				new LongScoreColumn("Total match", s -> s.get(Metric.SOFT_MATCH) + s.get(Metric.STRICT_MATCH)), //
				new LongScoreColumn("Error", Metric.ERROR), //
				new LongScoreColumn("Total", Metric.COUNT), //
				new LongScoreColumn("Single class predictions", Metric.SINGLE_CLASS), //
				new LongScoreColumn("Null predictions", Metric.NULL_CLASS));

		additionalEfficiencyColumns = Arrays.asList(//
				new ScoreColumn("Sum of p-values", Metric.SUM_OF_P_VALUES, true), //
				new ScoreColumn("Unconfidence", Metric.UNCONFIDENCE, true), //
				new ScoreColumn("Fuzziness", Metric.FUZZINESS, true), //
				new ScoreColumn("Observed Unconfidence", Metric.OBSERVED_UNCONFIDENCE, true), //
				new ScoreColumn("Observed Fuzziness", Metric.OBSERVED_FUZZINESS, true), //
				new ScoreColumn("Number of Labels", Metric.NUMBER_OF_LABELS, true), //
				new ScoreColumn("Multiple", Metric.MULTIPLE, true), //
				new ScoreColumn("Excess", Metric.EXCESS, true), //
				new ScoreColumn("Observed multiple", Metric.OBSERVED_MULTIPLE, true), //
				new ScoreColumn("Observed Excess", Metric.OBSERVED_EXCESS, true));
	}

	/**
	 * @return The output table spec.
	 */
	public DataTableSpec createOutputSpec() {
		List<DataColumnSpec> specs = new ArrayList<>();
		specs.add(new DataColumnSpecCreator("Target", StringCell.TYPE).createSpec());

		for (ScoreColumn c : getIncludedColumns()) {
			specs.add(c.createSpec());
		}

		return new DataTableSpec(specs.toArray(new DataColumnSpec[] {}));
	}

	private List<ScoreColumn> getIncludedColumns() {
		List<ScoreColumn> result = new ArrayList<>(baseColumns);
		if (model.isAdditionalInfoMode()) {
			result.addAll(additionalColumns);
		}
		if (model.isAdditionalEfficiencyMetricsMode()) {
			result.addAll(additionalEfficiencyColumns);
		}
		return result;
	}

	/**
	 * @param inTable Input table.
	 * @param exec    Execution context.
	 * @return The scores table.
	 * @throws CanceledExecutionException
	 */
	public BufferedDataTable process(BufferedDataTable inTable, ExecutionContext exec)
			throws CanceledExecutionException {
		Map<String, ClassScores> classScores = computeScores(inTable, exec);
		Scores totalScores = Scores.sum(classScores.values());
		return createOutputTable(classScores, totalScores, exec);
	}

	private Map<String, ClassScores> computeScores(BufferedDataTable inTable, ExecutionContext exec)
			throws CanceledExecutionException {
		Map<String, ClassScores> scores = new HashMap<>();
		DataTableSpec inputTableSpec = inTable.getSpec();

		DataTableSpec spec = inTable.getDataTableSpec();
		int targetIdx = spec.findColumnIndex(model.getTargetColumn());
		int classesIdx = spec.findColumnIndex(model.getClassesColumn());

		Map<String, Integer> pValueIdx = Collections.emptyMap();
		if (model.isAdditionalEfficiencyMetricsMode()) {
			pValueIdx = inputTableSpec.getColumnSpec(targetIdx).getDomain().getValues().stream().map(DataCell::toString)
					.collect(Collectors.toMap(str -> str,
							str -> inputTableSpec.findColumnIndex(model.getProbabilityColumnName(str))));
		}

		long total = inTable.size();
		long count = 0;

		for (DataRow row : inTable) {
			String target = row.getCell(targetIdx).toString();
			Set<String> classes = getClasses(row.getCell(classesIdx));
			ClassScores score = scores.computeIfAbsent(target, ClassScores::new);

			score.inc(Metric.COUNT);

			if (classes.contains(target)) {
				if (classes.size() == 1) {
					score.inc(Metric.STRICT_MATCH);
				} else {
					score.inc(Metric.SOFT_MATCH);
				}
			} else {
				score.inc(Metric.ERROR);
			}

			if (classes.isEmpty()) {
				score.inc(Metric.NULL_CLASS);
			} else if (classes.size() == 1) {
				score.inc(Metric.SINGLE_CLASS);
			}

			if (model.isAdditionalEfficiencyMetricsMode()) {
				Map<String, Double> pValues = pValueIdx.entrySet().stream()
						.collect(Collectors.toMap(Entry::getKey,
								e -> ((DoubleValue) row.getCell(e.getValue())).getDoubleValue()));

				double max = 0, second = 0, sum = 0;
				for (Double p : pValues.values()) {
					sum += p;
					score.add(Metric.SUM_OF_P_VALUES, p);// Average Sum of p-values
					if (p > max) {
						max = p;
						second = max;
					} else if (p > second) {
						second = p;
					}
				}
				score.add(Metric.UNCONFIDENCE, second);// Unconfidence
				score.add(Metric.FUZZINESS, sum - max);// Fuziness
				score.add(Metric.NUMBER_OF_LABELS, classes.size());
				if (classes.size() > 1)
					score.inc(Metric.MULTIPLE);
				score.add(Metric.EXCESS, classes.size() - 1);
				if (max == pValues.get(target))
					score.add(Metric.OBSERVED_UNCONFIDENCE, second);
				else
					score.add(Metric.OBSERVED_UNCONFIDENCE, max);
				score.add(Metric.OBSERVED_FUZZINESS, sum - pValues.get(target));// Observed Fuziness

				if (classes.contains(target)) {
					score.add(Metric.OBSERVED_EXCESS, classes.size() - 1);
					if (classes.size() > 1)
						score.inc(Metric.OBSERVED_MULTIPLE);
				} else {
					score.add(Metric.OBSERVED_EXCESS, classes.size());
					if (classes.size() > 0)
						score.inc(Metric.OBSERVED_MULTIPLE);
				}

			}

			exec.checkCanceled();
			exec.setProgress((double) count++ / total);
		}
		return scores;
	}

	private Set<String> getClasses(DataCell cell) {
		if (cell.isMissing()) {
			return Collections.emptySet();
		}
		if (cell.getType().isCollectionType()) {
			return ((CollectionDataValue) cell).stream().map(DataCell::toString).collect(toSet());
		} else {
			return new HashSet<>(Arrays.asList(cell.toString().split(model.getStringSeparator())));
		}
	}

	private BufferedDataTable createOutputTable(Map<String, ClassScores> scores, Scores totals,
			ExecutionContext exec) {
		BufferedDataContainer cont = exec.createDataContainer(createOutputSpec());
		List<ScoreColumn> includedColumns = getIncludedColumns();

		long idx = 0;
		for (ClassScores s : scores.values()) {
			cont.addRowToTable(createRow(s.getTarget(), includedColumns, s, idx++));
		}
		cont.addRowToTable(createRow("<Total>", includedColumns, totals, idx));
		cont.close();

		return cont.getTable();
	}

	private static DataRow createRow(String caption, List<ScoreColumn> columns, Scores score, long idx) {
		List<DataCell> cells = new ArrayList<>();
		cells.add(new StringCell(caption));
		for (ScoreColumn c : columns) {
				cells.add(c.createCell(score));
		}
		return new DefaultRow(RowKey.createRowKey(idx), cells);
	}

}
